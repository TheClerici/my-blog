---
layout: post
title:  "To Do App Technical Log"
date:   2022-11-24 16:18:25 -0000
category: Log
---

<h2><strong>To Do App REACT / SPRING BOOT</strong></h2>

![dev](https://github.com/TheClerici/my-blog/blob/main/images/dev.jpg?raw=true "Header")

------------------------------------------------------------------------------------------
<blockquote> <h3> General Overview: </h3> </blockquote> 

#### **Functional requirements:**

This is a project about an implementation of a to do list to help manage the tasks on a daily job, in order to achieve it, we were asked to follow a markup to design the app, it should include:

1. Search/Filtering Controls
2. New To Do Button. This should open a modal to type the “to do” data.
3. Priority column should show in the header the classic up and down arrows to allow the user to sort.
4. Due date column should show in the header the classic up and own arrows to allow the user to sort.
5. Action column to show actions (links/buttons) to allow the user to delete or edit a “to do”.
    * To Edit is ok to show a modal similar to the one to create a “to do”
6. Pagination control. Showing the pages, its number and the next and previous page is enough.
7. Area to show the metrics


<p align="center">
    <img width="600" src="https://github.com/TheClerici/my-blog/blob/main/images/markup.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 1. Design Markup</strong></h5>
</div>

For it, there were certain engineering requirements needed in order to implement the functionality of the app. Both front-end and back-end related. I will dive further into them later.

There will be no need to use a database by now, and we can store data in memory using Java Collections, it is also okay if data is lost when the app is shutdown. Some decisions were made based on that, because we were asked to design a persistent layer in which will be easy to switch from in-memory to database implementation.

------------------------------------------------------------------------------------------
<blockquote> <h3> Engineering Requirements: </h3> </blockquote>

#### **Backend Model:**

A "to do" should have the following properties:

* Id. This could be a number or string or a combination. Must be unique.
* Text (required). Max length is 120 chars.
* A due date (optional).
* Done/undone flag.
* A done date. When the “to do” is marked as done this date is set.
* Priority (required). Options: High, Medium and Low.
* Creation date.

#### **API:**

* A GET endpoint (/todos) to list “to do’s” 
    * Include pagination. Pages should be of 10 elements. 
    * Sort by priority and/or due date 
    * Filter by done/undone 
    * Filter by the name or part of the name 
    * Filter by priority 
* A POST endpoint (/todos) to create “to do’s” 
    * Validations included 
* A PUT endpoint (/todos/{id}) to update the “to do” name, due date and/or priority 
    * Validations included 
* A PUT/POST endpoint (/todos/{id}/done) to mark “to do” as done 
    * This should update the “done date” property 
    * If “to do” is already done nothing should happen (no error returned) 
* A PUT/POST endpoint (/todos/{id}/undone) to mark “to do” as undone 
    * If “to do” is already undone nothing should happen 
    * If “to do” is done, this should clear the done date

#### **Front-end Technology:**

For the front-end project, use:

* JavaScript
* ReactJS
* Redux or React Context

#### **Back-end Technology:**

For the back-end project, use:

* Java
* Maven
* Spring Boot

------------------------------------------------------------------------------------------
<blockquote> <h3> BACKEND: </h3> </blockquote>

#### **Structure:**

The structure of the application is divided in 4 sections: `Model`, `Controller`, `Service` and `Repository`.

<p align="center">
    <img width="400" src="https://github.com/TheClerici/my-blog/blob/main/images/structure.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 2. Structure</strong></h5>
</div>

There is also a main Backend Application that runs the app, this is achieved with the command _./mvnw spring-boot:run_ in the teminal and goes as follows:

_Backend Application:_

```java
@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}
}
```

To store, edit or delete my To Do's I decided to use HashMap lists, so I can use an ID key set with a counter to access them easier in the future, this is set in `Repository` as follows:

```java
private Integer idCounter = 1;
private HashMap<Integer, ToDo> toDos = new HashMap<>();
```

#### **Model:**

Here are all of the properties needed for the to do application to work correctly, as I made all business logic and validations on Service, we will always input data that won't compromise our program. The contructor only contains `id`, `text`, `dueDate` and `priority`, as the other parameters will be setup later by the user or by me to get certain attributes. Then, the getters and setters are defined (will only show one as an example but all the variables have them) along with the toString() Override in case I need it while testing.

I also added a variable called _betweenDate_ here to store the Duration between the creationDate and doneDate in order to get the metric parameters of the to do's.

_Model Class:_

```java
public class ToDo {

    //Variables
    private Integer id;
    private String text;
    private LocalDate dueDate;             
    private String priority;
    private String isDone;
    private LocalDateTime creationDate;
    private LocalDateTime doneDate;
    private Duration betweenDate;

    //Constructor
    public ToDo(Integer id, String text, LocalDate dueDate, String priority) {
        this.id = id;
        this.text = text;
        this.dueDate = dueDate;
        this.priority = priority;
        this.isDone = "undone";
        this.creationDate = LocalDateTime.now();
        this.doneDate = null;
        this.betweenDate = null;
    }

    //Getters and setters (only one shown as example)
    public Integer getId() { return id; }
    public void setId(Integer Id) { this.id = id; }

    //toString() @Override
}
```

#### **Controller:**

It's time to connect the Back to the Front and make the HTTP methods that are gonna be used to read, create, update and delete all the To Do's stored on our Collection, depending on what the user wants to see.

To make this possible, we used Annotations that Spring Boot provides us to handle the requests:

* `@RestController:` Allows the class to handle the requests made by the client.
* `@CrossOrigin:` Enables cross-origin resource sharing.
* `@Autowired:` Spring framework feature that enables to inject the object dependency implicitly.
* `@GetMapping:` It's used to handle GET type of request method. (READ)
* `@PostMapping:` It's used to handle POST type of request method. (CREATE)
* `@DeleteMapping:` It's used to handle DELETE type of request method. (DELETE)
* `@PutMapping:` It's used to handle PUT type of request method. (UPDATE)
* `@RequestMapping:` It's used to mark a class as a web request handler. (used as GET)

And finally, here is the Controller Class that handles the requests, all of them are connected to the `@Service` to validate and get to the in-memory repository (Collection I created in Service) and return the information needed to sent back to the Front. Comments are for every annotation purpose.

_Controller Class:_

```java
@RestController
@CrossOrigin(origins = "http://localhost:8080")
public class ToDoController {

    @Autowired
    private final ToDoService toDoService;

    //Service Constructor to access it from Controller.
    public ToDoController(ToDoService toDoService) {
        this.toDoService = toDoService;
    }

    //Receives Body from Front to create and add a new To Do to our Hashmap in Repository
    @PostMapping("/api/todos")
    public ResponseEntity<?> createToDo(@RequestBody ToDo toDo) { return toDoService.createToDo(toDo); }

    //Delete To Do by id received from Front
    @DeleteMapping("/api/todos/{id}")
    public ResponseEntity<?> deleteToDo(@PathVariable Integer id) { return toDoService.deleteToDo(id); }

    //Delete all To Do's
    @DeleteMapping("/api/todos")
    public ResponseEntity<?> deleteToDos() { return toDoService.deleteToDos(); }

    //Receives Body from Front to edit a To Do in our Hashmap in Repository by id
    @PutMapping("api/todos/{id}/{remove}")
    public HttpEntity<?> updateToDo(
            @PathVariable Integer id,
            @PathVariable String remove,
            @RequestBody ToDo toDo) { return toDoService.updateTodo(id, remove, toDo); }

    //Set To Do as Done by id
    @PutMapping("/api/todos/{id}/done")
    public HttpEntity<?> toDoDone(@PathVariable Integer id) { return toDoService.setToDoDone(id); }

    //Set To Do as Undone by id
    @PutMapping("/api/todos/{id}/undone")
    public HttpEntity<?> toDoUndone(@PathVariable Integer id) { return toDoService.setToDoUndone(id); }

    /*Receives a query string from Front that returns the metrics to show from Repo*/
    @GetMapping("/api/todos/stats")
    public ResponseEntity<?> getToDosStats() { return toDoService.getToDosStats(); }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return the size of the To Do's to the Front with filters, order and pagination.
    This is done to get the total number of pages for my To Do's table in my FrontEnd.*/
    @RequestMapping(value = "/api/todos/size", params = {"name", "priority", "isDone"})
    public ResponseEntity<?> getToDosSize(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone) {
        return toDoService.getToDosSize(name, priority, isDone);
    }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return all the To Do's to the Front to show the List with filters, order and pagination*/
    @RequestMapping(value = "/api/todos", params = {"name", "priority", "isDone", "priorityOrder", "dueDateOrder", "page"})
    public ResponseEntity<?> getToDosFiltered(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone,
            @RequestParam(required = false, defaultValue = "default") String priorityOrder,
            @RequestParam(required = false, defaultValue = "default") String dueDateOrder,
            @RequestParam(required = false, defaultValue = "1") String page) {
        return toDoService.getToDosFiltered(name, priority, isDone, priorityOrder, dueDateOrder, page);
    }
}
```

#### **Service:**

As I explained before, I have some validations that throws exceptions and the Front receives them, here are some examples that show what Status Exception is being called with a message accordingly to it. I will only refer to them as //Validations comment on my coding. Each Response Entity returns the corresponding code:

* `200 (OK)` for succesfull/normal responses.
* `404 (Not Fount)` for responses where a resource is not found.
* `201 (Created)` when a To Do is created.
* `400 (Bad Request)` for validation errors when creating a To Do.

_Validation examples:_

```java
//Example 1
if (toDos == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND, "No To-Do's found to delete.");

//Example 2
if (toDo.getText() != null) {
    if (toDo.getText().length() < 1)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be empty. Please fill!");
    else if (toDo.getText().length() > 120)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be more than 120 chars.");
}
```

As there is no Database (DB) to work with, I decided to create in my Service class a HashMap Java Collection to store my values. To Connect to a Repository Interface is not necesary, but I created it empty in case we need to use one in the future. My Service class will have all the logic set and To Do's.

* `@Service:` It is used to mark the class as a service provider.

There are important aspects to touch on the logic used to filter, order and paginate.

* `Filter:` This is achieved by searching on the Collection for the values received on Front such as Name, Priority and Done Flag with if statements regarding all the possible events.
* `Order:` This is achieved by setting first all the priorities to letters a, b and c, this is only to be able to stream it and order them with an alphabetic order. Then, ordering the collection with if statements depending on the values received from the front for priorityOrder and dueDateOrder regarding all the possible events. Later on, we re-assign "Low", "Medium" and "High" to the priority values on the Collection.
* `Pagination:` This is achieved by receiving the page number from the Front, where with the skip method you can set an offset to a list of values, this is needed to send values starting from a certain point. Example, list of 20 To Do's. If you set the offset to 10 you only get To Do's from 11 to 20. Then, limit the values set on the list to send to the Front with the limit function, this let's you limit how many items can be on a list. Example, list of 50 To Do's. If you set the limit to 10 you will only get the first 10 To Do's. So, by mixing these two together you can succesfully get the pagination.
    * `Example:` orderedToDosList = orderedToDosList.stream().skip(offset).limit(10).toList();

_Service Class:_

```java
@Service
public class ToDoService {

    private Integer idCounter = 1;

    //Java Collection that works as Repo
    private HashMap<Integer, ToDo> toDos = new HashMap<>();

    //Create a new To Do and adding it to my Collection.
    public ResponseEntity<?> createToDo(ToDo toDo) {
        //Validations
        ToDo newToDo = new ToDo(idCounter, toDo.getText(), toDo.getDueDate(), toDo.getPriority());
        toDos.put(idCounter, newToDo);
        return new ResponseEntity<>(toDos.get(idCounter++), HttpStatus.CREATED);
    }

    //Delete a todo and removing it from my Collection.
    public ResponseEntity<?> deleteToDo(Integer id) {
        //Validations
        toDos.remove(id);
        return ResponseEntity.ok(toDos.values());
    }

    //Delete All To Dos and reset the counter and Colection.
    public ResponseEntity<?> deleteToDos() {
        //Validations
        toDos = new HashMap<>();
        idCounter = 1;
        return ResponseEntity.ok(toDos.values());
    }

    //Updating a To Do in the Collection.
    public ResponseEntity<?> updateTodo(Integer id, String remove, ToDo toDo) {
        //Validations
        ToDo toDoUpdated = toDos.get(id);
        //More Validations
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Updating a To Do in the Collection by setting it to Done, adding done date and between date.
    public ResponseEntity<?> setToDoDone(Integer id) {
        ToDo toDoUpdated = toDos.get(id);
        //Validations
        toDoUpdated.setDoneDate(LocalDateTime.now());
        toDoUpdated.setIsDone("done");
        toDoUpdated.setBetweenDate(Duration.between(toDoUpdated.getCreationDate(), toDoUpdated.getDoneDate()));
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Updating a To Do in the Collection by setting it to Undone, deleting done date and between date.
    public ResponseEntity<?>  setToDoUndone(Integer id) {
        ToDo toDoUpdated = toDos.get(id);
        //Validations
        toDoUpdated.setDoneDate(null);
        toDoUpdated.setIsDone("undone");
        toDoUpdated.setBetweenDate(null);
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Getting the Metrics to show on Front
    public ResponseEntity<?> getToDosStats() {
        //Logic to get all the values from the To Dos in case they are set to "Done", this is why between date was created.
        return ResponseEntity.ok(stats);
    }

    //Getting the size of the filtered To Do's for pagination purposes on Front
    public ResponseEntity<?>  getToDosSize(String name, String priority, String isDone) {
        List<ToDo> toDosList = filter(name, priority, isDone);
        return ResponseEntity.ok(Math.max(toDosList.size(), 1));
    }

    public ResponseEntity<?> getToDosFiltered(String name, String priority, String isDone, String priorityOrder, String dueDateOrder, String page) {
        //Filter To Do's by name, priority and/or flag
        //Setting To Do priority to letters for order
        //Logic to order the To Do's depending on their priority order and due date order.
        //Setting To Do priority to Low, Medium and High to show on front
        //pagination logic
        return ResponseEntity.ok(orderedToDosList);
    }

    //Methods for simplification.

    //Get the To Do's Collection
    public HashMap<Integer, ToDo> getToDos() {
        return toDos;
    }

    //filter To Do's by name, priority and/or flag
    public  List<ToDo> filter(String name, String priority, String isDone) {
        //Logic to filter the To Dos depending on what's received.
        return toDosList;
    }

    //Reset values to empty and default for testing purposes. Will get into that the end of BACKEND.
    public void reset() {
        toDos = new HashMap<>();
        idCounter = 1;
    }
}
```

#### **Repository:**

As I mentioned before, there is no DB to work with, so here we have a Repository interface empty and ready to be extended to any repository that is gonna be used.

_Repository Interface:_

```java
@Repository
public interface ToDoRepository { 
}
```

#### **Tests:**

And finally, a Backend Application Tests that runs the backend tests for the app, this is achieved with the command _./mvnw test_ in the terminal.

Developers write unit tests for their code to make sure that the code works correctly, this helps to detect and protect against bugs in the future.

In order to succesfully Test the code, I @Autowired the ToDoService class to verify that I'm returning what I expect to the Front. I will only show 2-3 examples for the testing.

To make this possible, we used Annotations that Spring Boot provides us to handle the requests:

* `@SpringBootTest:` Tells Spring Boot to look for a main configuration class (one with @SpringBootApplication, for instance) and use that to start a Spring application context that will be utilized in our tests.
* `@Autowired:` Spring framework feature that enables to inject the object dependency implicitly.
* `@AfterEach:` It's used to signal that the annotated method should be executed after each @Test method in the current test class.
* `@Test:` This tells the JUnit test framework that this is an executable test method.

_Backend Application Tests:_

```java
@SpringBootTest
class BackendApplicationTests {

	@Autowired
	private ToDoService toDoService;

	@AfterEach
	void reset() { toDoService.reset(); }

    @Test
	void TestGetToDosFilteredEmpty() {
		ResponseEntity<?> response = toDoService.getToDosFiltered("default", "default","default","default","default", "1");
		List<ToDo> TODOS = new ArrayList<>();
		ResponseEntity<?> expected = ResponseEntity.ok(TODOS);
		assertEquals(expected, response);
	}

    @Test
	void createToDoWithNoBody() {
		try {
			ToDo todo = new ToDo(1, "", null, "");
			toDoService.createToDo(todo);
			fail();
		} catch (ResponseStatusException RSE) {
			assertEquals("To-Do has no body. Please fill!", RSE.getReason());
		}
	}

    @Test
	void successfullySetToDoToDone() {
		ToDo todo = new ToDo(1, "TEST", null, "Low");
		toDoService.createToDo(todo);

		toDoService.setToDoDone(1);
		HashMap<Integer, ToDo> TODOS = toDoService.getToDos();
		String response = TODOS.get(1).getIsDone();
		String expected = "done";
		assertEquals(expected, response);
	}
}
```

------------------------------------------------------------------------------------------
<blockquote> <h3> FRONTEND: </h3> </blockquote>

#### **Structure:**

The structure of the application `App.js` is divided in 5 components (sections): `filter`, `newToDoForm`, `table`, `pagination`, `stats` and a UI component for the Error modal when there is one.

<p align="center">
    <img width="400" src="https://github.com/TheClerici/my-blog/blob/main/images/frontstructure.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 3. Front Structure</strong></h5>
</div>

#### **App:**

Here is where all the logic to get the information from the backend is set, to do this, we need to set props for every component that return the information input by the user to add, delete, edit or filter all the To Do's on the Application.

Accordingly, all the variables needed to get the information through HTTP requests and the ones we get to display on the app are initiated here, and modified through state, as they are dynamic and need to be updated every change the user does. Variables:

* `toDos:` Stores the Collection to display on table.
* `stats:` Stores the Metrics to display on stats.
* `url:` Stores the url modified with the parameters of filters, order and pagination to use on GET and store To Do's.
* `urlPages:` Stores the url modified with filters to get the size of the To Do's list and implement pagination.
* `text:` Stores the text value that is used as a filter parameter.
* `priority:` Stores the priority value that is used as a filter parameter.
* `isDone:` Stores the flag value that is used as a filter parameter.
* `priorityOrder:` Stores the priority value that is used as an order parameter.
* `dueDateOrder:` Stores the due date value that is used as an order parameter.
* `page:` Stores the page value that is used as a pagination parameter.
* `nPages:` Stores the number of pages to display on pagination.
* `error:` Stores a true or false value that is activated by catch on Axios HTTP Rerquests to activate the Error Modal.
* `errorMsg:` Stores the error message to display on Error Modal.
* `status:` Stores the status of the error to display on Error Modal.
* `message:` Stores the message of the error to display on Error Modal.

In order to get the HTTP requests, we used Axios, which is a Javascript library used to make HTTP requests from node.js or XMLHttpRequests from the browser, the decision here was because Axios is best suited in terms of the transformation of data as it transforms data of JSON automatically.

This was achieved by using effect, by using this Hook, you tell React that your component needs to do something after render. Does _useEffect_ run after every render? Yes! By default, it runs both after the first render and after every update. This way instead of mounting and updating our list, we just GET our values after every render.

I will showcase the `GET` that is modified after every render and `POST` used to create a new To Do and add it to our Collection to display on our table, later on, I will explain all of the ones that are not showcased and how they work.

_HTTP Request Examples:_

```javascript
const App = () => {
    //Used to always have the To Do's Collection to Display on table, the size of the list to get number of pages and the stats for metrics.
    useEffect(() => {
        axios.get(url).then((response) => {setToDos(response.data)});
        axios.get(urlPages).then((response) => {setNPages(Math.ceil(response.data / 10))})
        axios.get("http://localhost:9090/api/todos/stats").then((response) => {setStats(response.data)})
      });

    //Used to create a new To Do and add it to our Collection.
    const addToDoHandler = (toDo) => {
        axios.post("http://localhost:9090/api/todos", toDo)
        .catch((error) => {
          setErrorMsg(error.response.data.error)
          setStatus(error.response.data.status)
          setMessage(error.response.data.message)
          setError(true)
        })
    }
}
```

Here is a list with all the requests that are handled:

1. `GET To Do's:` When the App is rendered GET the Collection to display on table component
2. `GET Pages:` When the App is rendered GET the size of the Collection to set the number of pages to display.
3. `GET Stats:` When the App is rendered GET the metrics to display on stats component.
4. `POST To Do:` Send post request to create new To Do.
5. `DELETE To Do's:` Send delete request to delete all To Do's.
6. `PUT To Do:` Send put request to edit a certain To Do.
7. `DELETE To Do:` Send delete request to delete a certain To Do.
8. `PUT Done:` Send put request to set certain To Do to "Done".
9. `PUT Undone:` Send put request to set certain To Do to "Undone".

All of the request are activated (the ones that are not on _useEffect_) by Handlers that we get from the different components that are set in the structure of our App.js, the handlers also modify certain parameter used on the GETs, then, as those parameters are modified they re-render to get those values, such as:

1. `filterToDosHanlder:` Edit text, priority and isDone parameters for the _GET To Do's_ url and the _GET Pages_ urlPages.
2. `priorityOrderHandler:` Edit priority order for the _GET To Do's_ url.
3. `dueDateOrderHandler:` Edit due date order for the _GET To Do's_ url.
4. `pageHandler:` Edit page for the _GET To Do's_ url.
5. `errorStateHandler:` To stop displaying the error modal when "Okay" button is clicked.

All the other handlers are like the examples shown above on the Highlight section inside FRONTEND -> App.

Main component `App.js` structure:

_App.js:_

```javascript
const App = () => {
    return (
        <div>
          {error && <ErrorModal error={errorMsg} status={status} message={message} onClose={() => errorStateHandler()}/>}
          <h3 className="app-header"> To-Do App </h3>
          <FilterToDos onFilterToDos={filterToDosHandler}/>
          <NewToDoandClearToDos 
         onAddToDo={addToDoHandler} 
         onDeleteToDos={deleteToDosHandler}
          />
          <ToDoTable 
            items={toDos}
            onEditToDo={editToDoHandler}
            onDelete={deleteToDoHandler}
            onPriorityOrder={priorityOrderHandler}
            onDueDateOrder={dueDateOrderHandler}
            onStatus={changeIsDoneHandler}
          />
          <Pagination
            totalPages={nPages}
            onPageChange={pageHandler}
          />
          <div className="total">Total pages: {nPages}</div>
          <Stats items={stats}/>
        </div>
    );
}
```

I will dive deeper into every component on the next sections of the Technical Log, in order of appereance and including the error modal, saying so, I will start with error modal.

#### **components -> UI  -> Error Modal:**







------------------------------------------------------------------------------------------
<blockquote> <h3> Extras: </h3> </blockquote>

Talk about ENUMS and using ResponseEntity instead of throw new ResponseStatusException.