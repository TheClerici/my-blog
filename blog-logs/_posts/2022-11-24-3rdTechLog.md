---
layout: post
title:  "To Do App Technical Log"
date:   2022-11-24 16:18:25 -0000
category: Log
---

<h2><strong>To Do App REACT / SPRING BOOT</strong></h2>

![dev](https://github.com/TheClerici/my-blog/blob/main/images/dev.jpg?raw=true "Header")

------------------------------------------------------------------------------------------
<blockquote> <h3> General Overview: </h3> </blockquote> 

#### **Functional requirements:**

This is a project about an implementation of a to do list to help manage the tasks on a daily job, in order to achieve it, we were asked to follow a markup to design the app, it should include:

1. Search/Filtering Controls
2. New To Do Button. This should open a modal to type the “to do” data.
3. Priority column should show in the header the classic up and down arrows to allow the user to sort.
4. Due date column should show in the header the classic up and own arrows to allow the user to sort.
5. Action column to show actions (links/buttons) to allow the user to delete or edit a “to do”.
    * To Edit is ok to show a modal similar to the one to create a “to do”
6. Pagination control. Showing the pages, its number and the next and previous page is enough.
7. Area to show the metrics


<p align="center">
    <img width="600" src="https://github.com/TheClerici/my-blog/blob/main/images/markup.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 1. Design Markup</strong></h5>
</div>

For it, there were certain engineering requirements needed in order to implement the functionality of the app. Both front-end and back-end related. I will dive further into them later.

There will be no need to use a database by now, and we can store data in memory using Java Collections, it is also okay if data is lost when the app is shutdown. Some decisions were made based on that, because we were asked to design a persistent layer in which will be easy to switch from in-memory to database implementation.

------------------------------------------------------------------------------------------
<blockquote> <h3> Engineering Requirements: </h3> </blockquote>

#### **Backend Model:**

A "to do" should have the following properties:

* Id. This could be a number or string or a combination. Must be unique.
* Text (required). Max length is 120 chars.
* A due date (optional).
* Done/undone flag.
* A done date. When the “to do” is marked as done this date is set.
* Priority (required). Options: High, Medium and Low.
* Creation date.

#### **API:**

* A GET endpoint (/todos) to list “to do’s” 
    * Include pagination. Pages should be of 10 elements. 
    * Sort by priority and/or due date 
    * Filter by done/undone 
    * Filter by the name or part of the name 
    * Filter by priority 
* A POST endpoint (/todos) to create “to do’s” 
    * Validations included 
* A PUT endpoint (/todos/{id}) to update the “to do” name, due date and/or priority 
    * Validations included 
* A PUT/POST endpoint (/todos/{id}/done) to mark “to do” as done 
    * This should update the “done date” property 
    * If “to do” is already done nothing should happen (no error returned) 
* A PUT/POST endpoint (/todos/{id}/undone) to mark “to do” as undone 
    * If “to do” is already undone nothing should happen 
    * If “to do” is done, this should clear the done date

#### **Front-end Technology:**

For the front-end project, use:

* JavaScript
* ReactJS
* Redux or React Context

#### **Back-end Technology:**

For the back-end project, use:

* Java
* Maven
* Spring Boot

------------------------------------------------------------------------------------------
<blockquote> <h3> BACKEND: </h3> </blockquote>

#### **Structure:**

The structure of the application is divided in 4 sections: `Model`, `Controller`, `Service` and `Repository`.

<p align="center">
    <img width="400" src="https://github.com/TheClerici/my-blog/blob/main/images/structure.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 2. Structure</strong></h5>
</div>

There is also a main Backend Application that runs the app, this is achieved with the command _./mvnw spring-boot:run_ and it goes as follows:

_BackendApplication:_

{% highlight java %}
@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}
}
{% endhighlight %}

To store, edit or delete my To Do's I decided to use HashMap lists, so I can use an ID key set with a counter to access them easier in the future, this is set in `Repository` as follows:

{% highlight java %}
private Integer idCounter = 1;
private HashMap<Integer, ToDo> toDos = new HashMap<>();
{% endhighlight %}

#### **Model:**

Here are all of the properties needed for the to do application to work correctly, as I made all the validations on Controller and Repository, we will always input data that won't compromise our program. The contructor only contains `id`, `text`, `dueDate` and `priority`, as the other parameters will be setup later by the user or by me to get certain attributes. Then, the getters and setters are defined (will only show one as an example but all the variables have them) along with the toString() Override in case I need it while testing.

I also added a variable called _betweenDate_ here to store the Duration between the creationDate and doneDate in order to get the metric parameters of the to do's.

_Model:_

{% highlight java %}
public class ToDo {

    //Variables
    private Integer id;
    private String text;
    private LocalDate dueDate;             
    private String priority;
    private String isDone;
    private LocalDateTime creationDate;
    private LocalDateTime doneDate;
    private Duration betweenDate;

    //Constructor
    public ToDo(Integer id, String text, LocalDate dueDate, String priority) {
        this.id = id;
        this.text = text;
        this.dueDate = dueDate;
        this.priority = priority;
        this.isDone = "undone";
        this.creationDate = LocalDateTime.now();
        this.doneDate = null;
        this.betweenDate = null;
    }

    //Getters and setters (only one shown as example)
    public Integer getId() { return id; }
    public void setId(Integer Id) { this.id = id; }

    //toString() @Override
}
{% endhighlight %}

#### **Controller:**

It's time to connect the Back to the Front and make the HTTP methods that are gonna be used to read, create, update and delete all the To Do's stored on our Collection, depending on what the user wants to see.

To make this possible, we used Annotations that Spring Boot provides us to handle the requests:

* `@RestController:` Allows the class to handle the requests made by the client.
* `@CrossOrigin:` Enables cross-origin resource sharing.
* `@Autowired:` Spring framework feature that enables to inject the object dependency implicitly.
* `@GetMapping:` It's used to handle GET type of request method. (READ)
* `@PostMapping:` It's used to handle POST type of request method. (CREATE)
* `@DeleteMapping:` It's used to handle DELETE type of request method. (DELETE)
* `@PutMapping:` It's used to handle PUT type of request method. (UPDATE)
* `@RequestMapping:` It's used to mark a class as a web request handler. (used as GET)

As I explained before, I have some validations that throws exceptions and the Front receives them, here are some examples that show what Status Exception is being called with a message accordingly to it. I will only refer to them as //Validations comment on my coding. Each Response Entity returns the corresponding code:

* 200 (OK) for succesfull/normal responses.
* 404 (Not Fount) for responses where a resource is not found.
* 201 (Created) when a To Do is created.
* 400 (Bad Request) for validation errors when creating a To Do.

_Validation examples:_

{% highlight java %}
//Example 1
if (toDos == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND, "No To-Do's found to delete.");

//Example 2
if (toDo.getText() != null) {
    if (toDo.getText().length() < 1)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be empty. Please fill!");
    else if (toDo.getText().length() > 120)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be more than 120 chars.");
}
{% endhighlight %}

And finally, here is the Controller Class that handles the requests, all of them are connected to the `@Service` in order to get to the repository and return the information needed to sent back to the Front. Comments are for every annotation purpose.

_Controller:_

{% highlight java %}
@RestController
@CrossOrigin(origins = "http://localhost:8080")
public class ToDoController {

    @Autowired
    private ToDoService toDoService;

    //Receives Body from Front to create and add a new To Do to our Hashmap in Repository
    @PostMapping("/api/todos")
    public ResponseEntity<?> createToDo(@RequestBody ToDo toDo) {
        //Validations
        ToDo newToDo = toDoService.createToDo(toDo);
        //Validations
        return new ResponseEntity<>(newToDo, HttpStatus.CREATED);
    }

    //Delete To Do by id received from Front
    @DeleteMapping("/api/todos/{id}")
    public ResponseEntity<?> deleteToDo(@PathVariable Integer id) {
        HashMap<Integer, ToDo> toDos = toDoService.deleteToDo(id);
        //Validations
        return ResponseEntity.ok(toDos.values());
    }

    //Delete all To Do's
    @DeleteMapping("/api/todos")
    public ResponseEntity<?> deleteToDos() {
        HashMap<Integer, ToDo> toDos = toDoService.deleteToDos();
        //Validations
        return ResponseEntity.ok(toDos.values());
    }

    //Receives Body from Front to edit a To Do in our Hashmap in Repository by id
    @PutMapping("api/todos/{id}/{remove}")
    public HttpEntity<?> updateToDo(
            @PathVariable Integer id,
            @PathVariable String remove,
            @RequestBody ToDo toDo) {
        //Validations
        ToDo updatedToDo = toDoService.updateTodo(id, remove, toDo);
        //Validations
        return ResponseEntity.ok(updatedToDo);
    }

    //Set To Do as Done by id
    @PutMapping("/api/todos/{id}/done")
    public HttpEntity<?> toDoDone(@PathVariable Integer id) {
        ToDo updatedToDo = toDoService.setToDoDone(id);
        //Validations
        return  ResponseEntity.ok(updatedToDo);
    }

    //Set To Do as Undone by id
    @PutMapping("/api/todos/{id}/undone")
    public HttpEntity<?> toDoUndone(@PathVariable Integer id) {
        ToDo updatedToDo = toDoService.setToDoUndone(id);
        //Validations
        return  ResponseEntity.ok(updatedToDo);
    }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return all the To Do's to the Front to show the List with filters, order and pagination*/
    @RequestMapping(value = "/api/todos", params = {"name", "priority", "isDone", "priorityOrder", "dueDateOrder", "page"})
    public ResponseEntity<?> getToDosFiltered(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone,
            @RequestParam(required = false, defaultValue = "default") String priorityOrder,
            @RequestParam(required = false, defaultValue = "default") String dueDateOrder,
            @RequestParam(required = false, defaultValue = "1") String page){
        List<ToDo> orderedList = toDoService.getToDosFiltered(name, priority, isDone, priorityOrder, dueDateOrder, page);
        return ResponseEntity.ok(orderedList);
    }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return the size of the To Do's to the Front with filters, order and pagination.
    This is done to get the total number of pages for my To Do's table in my FrontEnd.*/
    @RequestMapping(value = "/api/todos/size", params = {"name", "priority", "isDone"})
    public ResponseEntity<?> getToDosSize(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone) {
        Integer toDosSize = toDoService.getToDosSize(name, priority, isDone);
        return ResponseEntity.ok(toDosSize);
    }

    /*Receives a query string from Front that returns the metrics to show from Repo*/
    @GetMapping("/api/todos/stats")
    public ResponseEntity<?> getToDosStats() {
        List<Long> toDosStats = toDoService.getToDosStats();
        return ResponseEntity.ok(toDosStats);
    }
}
{% endhighlight %}

#### **Service:**

As there is no Database (DB) to work with, I decided to use my Service to Connect to a Repository Class where I have my Collection, I will use the Service to connect with a DB and send that info to my Repository class where I have all of my business logic if there is ever a DB to work with. Saying so, my Service class will act as a connection to the DB and my Repo class that has all the logic set. This being said, I will only show 4 examples (CRUD, one each) as they all work the same and send the info received from the controller to the repository.

* `@Service:` It is used to mark the class as a service provider.

{% highlight java %}
@Service
public class ToDoService {

    @Autowired
    private ToDoRepository toDoRepository;

    //POST
    public ToDo createToDo(ToDo toDo) {
        return toDoRepository.createToDo(toDo);
    }

    //DELETE
    public HashMap<Integer, ToDo> deleteToDo(Integer id) {
        return toDoRepository.deleteToDo(id);
    }

    //PUT
    public ToDo updateTodo(Integer id, String remove, ToDo toDo) {
        return toDoRepository.updateToDo(id, remove, toDo);
    }

    //READ
    public List<ToDo> getToDosFiltered(String name, String priority, String isDone, String priorityOrder, String dueDateOrder, String page) {
        return toDoRepository.getToDosFiltered(name, priority, isDone, priorityOrder, dueDateOrder, page);
    }
}
{% endhighlight %}

#### **Repository:**