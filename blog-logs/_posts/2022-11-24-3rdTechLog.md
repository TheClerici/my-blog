---
layout: post
title:  "To Do App Technical Log"
date:   2022-11-24 16:18:25 -0000
category: Log
---

<h2><strong>To Do App REACT / SPRING BOOT</strong></h2>

![dev](https://github.com/TheClerici/my-blog/blob/main/images/dev.jpg?raw=true "Header")

------------------------------------------------------------------------------------------
<blockquote> <h3> General Overview: </h3> </blockquote> 

#### **Functional requirements:**

This is a project about an implementation of a to do list to help manage the tasks on a daily job, in order to achieve it, we were asked to follow a markup to design the app, it should include:

1. Search/Filtering Controls
2. New To Do Button. This should open a modal to type the “to do” data.
3. Priority column should show in the header the classic up and down arrows to allow the user to sort.
4. Due date column should show in the header the classic up and own arrows to allow the user to sort.
5. Action column to show actions (links/buttons) to allow the user to delete or edit a “to do”.
    * To Edit is ok to show a modal similar to the one to create a “to do”
6. Pagination control. Showing the pages, its number and the next and previous page is enough.
7. Area to show the metrics


<p align="center">
    <img width="600" src="https://github.com/TheClerici/my-blog/blob/main/images/markup.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 1. Design Markup</strong></h5>
</div>

For it, there were certain engineering requirements needed in order to implement the functionality of the app. Both front-end and back-end related. I will dive further into them later.

There will be no need to use a database by now, and we can store data in memory using Java Collections, it is also okay if data is lost when the app is shutdown. Some decisions were made based on that, because we were asked to design a persistent layer in which will be easy to switch from in-memory to database implementation.

------------------------------------------------------------------------------------------
<blockquote> <h3> Engineering Requirements: </h3> </blockquote>

#### **Backend Model:**

A "to do" should have the following properties:

* Id. This could be a number or string or a combination. Must be unique.
* Text (required). Max length is 120 chars.
* A due date (optional).
* Done/undone flag.
* A done date. When the “to do” is marked as done this date is set.
* Priority (required). Options: High, Medium and Low.
* Creation date.

#### **API:**

* A GET endpoint (/todos) to list “to do’s” 
    * Include pagination. Pages should be of 10 elements. 
    * Sort by priority and/or due date 
    * Filter by done/undone 
    * Filter by the name or part of the name 
    * Filter by priority 
* A POST endpoint (/todos) to create “to do’s” 
    * Validations included 
* A PUT endpoint (/todos/{id}) to update the “to do” name, due date and/or priority 
    * Validations included 
* A PUT/POST endpoint (/todos/{id}/done) to mark “to do” as done 
    * This should update the “done date” property 
    * If “to do” is already done nothing should happen (no error returned) 
* A PUT/POST endpoint (/todos/{id}/undone) to mark “to do” as undone 
    * If “to do” is already undone nothing should happen 
    * If “to do” is done, this should clear the done date

#### **Front-end Technology:**

For the front-end project, use:

* JavaScript
* ReactJS
* Redux or React Context

#### **Back-end Technology:**

For the back-end project, use:

* Java
* Maven
* Spring Boot

------------------------------------------------------------------------------------------
<blockquote> <h3> BACKEND: </h3> </blockquote>

#### **Structure:**

The structure of the application is divided in 4 sections: `Model`, `Controller`, `Service` and `Repository`.

<p align="center">
    <img width="400" src="https://github.com/TheClerici/my-blog/blob/main/images/structure.jpg?raw=true">
</p>
<div align="center">
    <h5><strong>Fig 2. Structure</strong></h5>
</div>

There is also a main Backend Application that runs the app, this is achieved with the command _./mvnw spring-boot:run_ in the teminal and goes as follows:

_BackendApplication:_

{% highlight java %}
@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}
}
{% endhighlight %}

To store, edit or delete my To Do's I decided to use HashMap lists, so I can use an ID key set with a counter to access them easier in the future, this is set in `Repository` as follows:

{% highlight java %}
private Integer idCounter = 1;
private HashMap<Integer, ToDo> toDos = new HashMap<>();
{% endhighlight %}

#### **Model:**

Here are all of the properties needed for the to do application to work correctly, as I made all business logic and validations on Service, we will always input data that won't compromise our program. The contructor only contains `id`, `text`, `dueDate` and `priority`, as the other parameters will be setup later by the user or by me to get certain attributes. Then, the getters and setters are defined (will only show one as an example but all the variables have them) along with the toString() Override in case I need it while testing.

I also added a variable called _betweenDate_ here to store the Duration between the creationDate and doneDate in order to get the metric parameters of the to do's.

_Model:_

{% highlight java %}
public class ToDo {

    //Variables
    private Integer id;
    private String text;
    private LocalDate dueDate;             
    private String priority;
    private String isDone;
    private LocalDateTime creationDate;
    private LocalDateTime doneDate;
    private Duration betweenDate;

    //Constructor
    public ToDo(Integer id, String text, LocalDate dueDate, String priority) {
        this.id = id;
        this.text = text;
        this.dueDate = dueDate;
        this.priority = priority;
        this.isDone = "undone";
        this.creationDate = LocalDateTime.now();
        this.doneDate = null;
        this.betweenDate = null;
    }

    //Getters and setters (only one shown as example)
    public Integer getId() { return id; }
    public void setId(Integer Id) { this.id = id; }

    //toString() @Override
}
{% endhighlight %}

#### **Controller:**

It's time to connect the Back to the Front and make the HTTP methods that are gonna be used to read, create, update and delete all the To Do's stored on our Collection, depending on what the user wants to see.

To make this possible, we used Annotations that Spring Boot provides us to handle the requests:

* `@RestController:` Allows the class to handle the requests made by the client.
* `@CrossOrigin:` Enables cross-origin resource sharing.
* `@Autowired:` Spring framework feature that enables to inject the object dependency implicitly.
* `@GetMapping:` It's used to handle GET type of request method. (READ)
* `@PostMapping:` It's used to handle POST type of request method. (CREATE)
* `@DeleteMapping:` It's used to handle DELETE type of request method. (DELETE)
* `@PutMapping:` It's used to handle PUT type of request method. (UPDATE)
* `@RequestMapping:` It's used to mark a class as a web request handler. (used as GET)

And finally, here is the Controller Class that handles the requests, all of them are connected to the `@Service` to validate and get to the in-memory repository (Collection I created in Service) and return the information needed to sent back to the Front. Comments are for every annotation purpose.

_Controller:_

{% highlight java %}
@RestController
@CrossOrigin(origins = "http://localhost:8080")
public class ToDoController {

    @Autowired
    private final ToDoService toDoService;

    //Service Constructor to access it from Controller.
    public ToDoController(ToDoService toDoService) {
        this.toDoService = toDoService;
    }

    //Receives Body from Front to create and add a new To Do to our Hashmap in Repository
    @PostMapping("/api/todos")
    public ResponseEntity<?> createToDo(@RequestBody ToDo toDo) { return toDoService.createToDo(toDo); }

    //Delete To Do by id received from Front
    @DeleteMapping("/api/todos/{id}")
    public ResponseEntity<?> deleteToDo(@PathVariable Integer id) { return toDoService.deleteToDo(id); }

    //Delete all To Do's
    @DeleteMapping("/api/todos")
    public ResponseEntity<?> deleteToDos() { return toDoService.deleteToDos(); }

    //Receives Body from Front to edit a To Do in our Hashmap in Repository by id
    @PutMapping("api/todos/{id}/{remove}")
    public HttpEntity<?> updateToDo(
            @PathVariable Integer id,
            @PathVariable String remove,
            @RequestBody ToDo toDo) { return toDoService.updateTodo(id, remove, toDo); }

    //Set To Do as Done by id
    @PutMapping("/api/todos/{id}/done")
    public HttpEntity<?> toDoDone(@PathVariable Integer id) { return toDoService.setToDoDone(id); }

    //Set To Do as Undone by id
    @PutMapping("/api/todos/{id}/undone")
    public HttpEntity<?> toDoUndone(@PathVariable Integer id) { return toDoService.setToDoUndone(id); }

    /*Receives a query string from Front that returns the metrics to show from Repo*/
    @GetMapping("/api/todos/stats")
    public ResponseEntity<?> getToDosStats() { return toDoService.getToDosStats(); }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return the size of the To Do's to the Front with filters, order and pagination.
    This is done to get the total number of pages for my To Do's table in my FrontEnd.*/
    @RequestMapping(value = "/api/todos/size", params = {"name", "priority", "isDone"})
    public ResponseEntity<?> getToDosSize(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone) {
        return toDoService.getToDosSize(name, priority, isDone);
    }

    /*Receives a query string from Front with defined params, it will read every parameter in order to reach the Repo
    with that info and return all the To Do's to the Front to show the List with filters, order and pagination*/
    @RequestMapping(value = "/api/todos", params = {"name", "priority", "isDone", "priorityOrder", "dueDateOrder", "page"})
    public ResponseEntity<?> getToDosFiltered(
            @RequestParam(required = false, defaultValue = "default") String name,
            @RequestParam(required = false, defaultValue = "default") String priority,
            @RequestParam(required = false, defaultValue = "default") String isDone,
            @RequestParam(required = false, defaultValue = "default") String priorityOrder,
            @RequestParam(required = false, defaultValue = "default") String dueDateOrder,
            @RequestParam(required = false, defaultValue = "1") String page) {
        return toDoService.getToDosFiltered(name, priority, isDone, priorityOrder, dueDateOrder, page);
    }
}
{% endhighlight %}

#### **Service:**

As I explained before, I have some validations that throws exceptions and the Front receives them, here are some examples that show what Status Exception is being called with a message accordingly to it. I will only refer to them as //Validations comment on my coding. Each Response Entity returns the corresponding code:

* 200 (OK) for succesfull/normal responses.
* 404 (Not Fount) for responses where a resource is not found.
* 201 (Created) when a To Do is created.
* 400 (Bad Request) for validation errors when creating a To Do.

_Validation examples:_

{% highlight java %}
//Example 1
if (toDos == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND, "No To-Do's found to delete.");

//Example 2
if (toDo.getText() != null) {
    if (toDo.getText().length() < 1)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be empty. Please fill!");
    else if (toDo.getText().length() > 120)
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "To-Do name can't be more than 120 chars.");
}
{% endhighlight %}

As there is no Database (DB) to work with, I decided to create in my Service class a HashMap Java Collection to store my values. To Connect to a Repository Interface is not necesary, but I created it empty in case we need to use one in the future. My Service class will have all the logic set and To Do's.

* `@Service:` It is used to mark the class as a service provider.

There are important aspects to touch on the logic used to filter, order and paginate.

`Filter:` This is achieved by searching on the Collection for the values received on Front such as Name, Priority and Done Flag with if statements regarding all the possible events.

`Order:` This is achieved by setting first all the priorities to letters a, b and c, this is only to be able to stream it and order them with an alphabetic order. Then, ordering the collection with if statements depending on the values received from the front for priorityOrder and dueDateOrder regarding all the possible events. Later on, we re-assign "Low", "Medium" and "High" to the priority values on the Collection.

`Pagination:` This is achieved by receiving the page number from the Front, where with the skip method you can set an offset to a list of values, this is needed to send values starting from a certain point. Example, list of 20 To Do's. If you set the offset to 10 you only get To Do's from 11 to 20. Then, limit the values set on the list to send to the Front with the limit function, this let's you limit how many items can be on a list. Example, list of 50 To Do's. If you set the limit to 10 you will only get the first 10 To Do's. So, by mixing these two together you can succesfully get the pagination.

orderedToDosList = orderedToDosList.stream().skip(offset).limit(10).toList();

{% highlight java %}
@Service
public class ToDoService {

    private Integer idCounter = 1;

    //Java Collection that works as Repo
    private HashMap<Integer, ToDo> toDos = new HashMap<>();

    //Create a new To Do and adding it to my Collection.
    public ResponseEntity<?> createToDo(ToDo toDo) {
        //Validations
        ToDo newToDo = new ToDo(idCounter, toDo.getText(), toDo.getDueDate(), toDo.getPriority());
        toDos.put(idCounter, newToDo);
        return new ResponseEntity<>(toDos.get(idCounter++), HttpStatus.CREATED);
    }

    //Delete a todo and removing it from my Collection.
    public ResponseEntity<?> deleteToDo(Integer id) {
        //Validations
        toDos.remove(id);
        return ResponseEntity.ok(toDos.values());
    }

    //Delete All To Dos and reset the counter and Colection.
    public ResponseEntity<?> deleteToDos() {
        //Validations
        toDos = new HashMap<>();
        idCounter = 1;
        return ResponseEntity.ok(toDos.values());
    }

    //Updating a To Do in the Collection.
    public ResponseEntity<?> updateTodo(Integer id, String remove, ToDo toDo) {
        //Validations
        ToDo toDoUpdated = toDos.get(id);
        //More Validations
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Updating a To Do in the Collection by setting it to Done, adding done date and between date.
    public ResponseEntity<?> setToDoDone(Integer id) {
        ToDo toDoUpdated = toDos.get(id);
        //Validations
        toDoUpdated.setDoneDate(LocalDateTime.now());
        toDoUpdated.setIsDone("done");
        toDoUpdated.setBetweenDate(Duration.between(toDoUpdated.getCreationDate(), toDoUpdated.getDoneDate()));
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Updating a To Do in the Collection by setting it to Undone, deleting done date and between date.
    public ResponseEntity<?>  setToDoUndone(Integer id) {
        ToDo toDoUpdated = toDos.get(id);
        //Validations
        toDoUpdated.setDoneDate(null);
        toDoUpdated.setIsDone("undone");
        toDoUpdated.setBetweenDate(null);
        toDos.put(id, toDoUpdated);
        return ResponseEntity.ok(toDos.get(id));
    }

    //Getting the Metrics to show on Front
    public ResponseEntity<?> getToDosStats() {
        //Logic to get all the values from the To Dos in case they are set to "Done", this is why between date was created.
        return ResponseEntity.ok(stats);
    }

    //Getting the size of the filtered To Do's for pagination purposes on Front
    public ResponseEntity<?>  getToDosSize(String name, String priority, String isDone) {
        List<ToDo> toDosList = filter(name, priority, isDone);
        return ResponseEntity.ok(Math.max(toDosList.size(), 1));
    }

    public ResponseEntity<?> getToDosFiltered(String name, String priority, String isDone, String priorityOrder, String dueDateOrder, String page) {
        //Filter To Do's by name, priority and/or flag
        //Setting To Do priority to letters for order
        //Logic to order the To Do's depending on their priority order and due date order.
        //Setting To Do priority to Low, Medium and High to show on front
        //pagination logic
        return ResponseEntity.ok(orderedToDosList);
    }

    //Methods for simplification.

    //Get the To Do's Collection
    public HashMap<Integer, ToDo> getToDos() {
        return toDos;
    }

    //filter To Do's by name, priority and/or flag
    public  List<ToDo> filter(String name, String priority, String isDone) {
        //Logic to filter the To Dos depending on what's received.
        return toDosList;
    }

    //Reset values to empty and default for testing purposes. Will get into that the end of BACKEND.
    public void reset() {
        toDos = new HashMap<>();
        idCounter = 1;
    }
}
{% endhighlight %}

#### **Repository:**

As I mentioned before, there is no DB to work with, so here we have a Repository interface empty and ready to be extended to any repository that is gonna be used.

{% highlight java %}
@Repository
public interface ToDoRepository { 
}
{% endhighlight %}

#### **Tests:**

And finally, a Backend Application Tests that runs the backend tests for the app, this is achieved with the command _./mvnw test_ in the terminal.

Developers write unit tests for their code to make sure that the code works correctly, this helps to detect and protect against bugs in the future.

In order to succesfully Test the code, I @Autowired the ToDoService class to verify that I'm returning what I expect to the Front. I will only show 2-3 examples for the testing.

To make this possible, we used Annotations that Spring Boot provides us to handle the requests:

* `@SpringBootTest:` Tells Spring Boot to look for a main configuration class (one with @SpringBootApplication, for instance) and use that to start a Spring application context that will be utilized in our tests.
* `@Autowired:` Spring framework feature that enables to inject the object dependency implicitly.
* `@AfterEach:` It's used to signal that the annotated method should be executed after each @Test method in the current test class.
* `@Test:` This tells the JUnit test framework that this is an executable test method.


{% highlight java %}
@SpringBootTest
class BackendApplicationTests {

	@Autowired
	private ToDoService toDoService;

	@AfterEach
	void reset() {
		toDoService.reset();
	}

    @Test
	void TestGetToDosFilteredEmpty() {
		ResponseEntity<?> response = toDoService.getToDosFiltered("default", "default","default","default","default", "1");
		List<ToDo> TODOS = new ArrayList<>();
		ResponseEntity<?> expected = ResponseEntity.ok(TODOS);
		assertEquals(expected, response);
	}

    @Test
	void createToDoWithNoBody() {
		try {
			ToDo todo = new ToDo(1, "", null, "");
			toDoService.createToDo(todo);
			fail();
		} catch (ResponseStatusException RSE) {
			assertEquals("To-Do has no body. Please fill!", RSE.getReason());
		}
	}

    @Test
	void successfullySetToDoToDone() {
		ToDo todo = new ToDo(1, "TEST", null, "Low");
		toDoService.createToDo(todo);

		toDoService.setToDoDone(1);
		HashMap<Integer, ToDo> TODOS = toDoService.getToDos();
		String response = TODOS.get(1).getIsDone();
		String expected = "done";
		assertEquals(expected, response);
	}
}
{% endhighlight %}

------------------------------------------------------------------------------------------
<blockquote> <h3> FRONTEND: </h3> </blockquote>

#### **Structure:**